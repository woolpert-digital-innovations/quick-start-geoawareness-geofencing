const test = require('ava');
const repository = require('../src/repository');
const utils = require('./test_utils');
const chance = require('chance').Chance();

test('getStore no store', async t => {
    const store = await repository.getStore(chance.word());
    t.is(store, null);
});

test('getStore store exists', async t => {
    const storeName = chance.word();
    let store = utils.createStore(storeName);
    await repository.insertStore(store);
    store = await repository.getStore(storeName);;
    t.is(store.name, storeName);
    repository.deleteStore(storeName);
});

test('getStores store exists', async t => {
    const storeName = chance.word();
    let store = utils.createStore(storeName);
    await repository.insertStore(store);
    const stores = await repository.getStores(storeName);;
    t.assert(stores.find(store => store.name === storeName));
    repository.deleteStore(storeName);
});

test('getGeofencesByStore store exists', async t => {
    const storeName = chance.word();
    let store = utils.createStore(storeName);
    let expected = utils.createGeofences();
    await Promise.all([repository.insertStore(store), repository.insertGeofences(expected, storeName)]);

    const actual = await repository.getGeofencesByStore(storeName);
    const ids = actual.map(geofence => geofence.id);
    // remove id as it's generated by database and therefore not available for assertion
    actual.forEach(element => {
        delete element.id;
    });
    t.deepEqual(actual, expected);

    repository.deleteGeofences(ids, storeName);
    repository.deleteStore(storeName);
});

test('getGeofencesByStore no store', async t => {
    const geofences = await repository.getGeofencesByStore(chance.word());
    t.deepEqual(geofences, []);
});

test('getOrdersByStore', async t => {
    const storeName = chance.word();
    let store = utils.createStore(storeName);
    const expected = utils.createOrders(storeName);
    expected.sort((first, second) => first.orderId - second.orderId);
    await Promise.all([repository.insertStore(store), repository.saveOrders(expected)]);

    const orders = await repository.getOrdersByStore(storeName);
    orders.sort((first, second) => first.orderId - second.orderId);

    t.deepEqual(orders, expected);

    repository.deleteOrders(orders.map(order => order.orderId), storeName);
    repository.deleteStore(storeName);
});

test('getOrdersByStore open orders', async t => {
    const storeName = chance.word();
    let store = utils.createStore(storeName);
    const expected = utils.createOrders(storeName);
    expected.sort((first, second) => first.orderId - second.orderId);
    await Promise.all([repository.insertStore(store), repository.saveOrders(expected)]);

    const orders = await repository.getOrdersByStore(storeName, 'open');
    orders.sort((first, second) => first.orderId - second.orderId);

    const openOrders = expected.filter(order => {
        return order.status.find(status => status == 'open');
    });
    t.deepEqual(orders, openOrders);

    repository.deleteOrders(orders.map(order => order.orderId), storeName);
    repository.deleteStore(storeName);
});

test('saveOrder insert', async t => {
    const storeName = chance.word();
    let store = utils.createStore(storeName);
    const expected = utils.createOrder(storeName);
    await Promise.all([repository.insertStore(store), repository.saveOrder(expected)]);

    const order = await repository.getOrder(expected.orderId, storeName);

    t.deepEqual(order, expected);

    repository.deleteOrder(expected.orderId, storeName);
    repository.deleteStore(storeName);
});

test('saveOrder update', async t => {
    const storeName = chance.word();
    let store = utils.createStore(storeName);
    const order = utils.createOrder(storeName);
    await Promise.all([repository.insertStore(store), repository.saveOrder(order)]);

    const originalOrder = await repository.getOrder(order.orderId, storeName);

    const changedOrder = {
        ...originalOrder,
        latestEvent: utils.createLatestEvent()
    }
    await repository.saveOrder(changedOrder);
    const updatedOrder = await repository.getOrder(order.orderId, storeName);
    const expected = {
        ...order,
        latestEvent: utils.createLatestEvent()
    }
    t.deepEqual(updatedOrder, expected);

    repository.deleteOrder(order.orderId, storeName);
    await repository.deleteStore(storeName);
});
