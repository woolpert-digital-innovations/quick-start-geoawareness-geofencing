const test = require('ava');
const repository = require('../repository');
const utils = require('./test_utils');
const chance = require('chance').Chance();

test('getStore no store', async t => {
    const store = await repository.getStore(chance.word());
    t.is(store, null);
});

test('getStore store exists', async t => {
    const storeName = chance.word();
    let store = utils.createStore(storeName);
    await repository.insertStore(store);
    store = await repository.getStore(storeName);;
    t.is(store.name, storeName);
    await repository.deleteStore(storeName);
});

test('getGeofencesByStore store exists', async t => {
    const storeName = chance.word();
    let store = utils.createStore(storeName);
    await repository.insertStore(store);

    let expected = utils.createGeofences();
    await repository.insertGeofences(expected, storeName);
    const actual = await repository.getGeofencesByStore(storeName);
    const ids = actual.map(geofence => geofence.id);
    // remove id as it's generated by database and therefore not available for assertion
    actual.forEach(element => {
        delete element.id;
    });
    t.deepEqual(actual, expected);

    await repository.deleteGeofences(ids, storeName);
    await repository.deleteStore(storeName);
});

test('getGeofencesByStore no store', async t => {
    const geofences = await repository.getGeofencesByStore(chance.word());
    t.deepEqual(geofences, []);
});

test('getOrdersByStore store exists', async t => {
    const storeName = chance.word();
    let store = utils.createStore(storeName);
    await repository.insertStore(store);

    const expected = utils.createOrders(storeName);
    for (let i = 0; i < expected.length; i++) {
        await repository.saveOrder(expected[i], storeName);
    }
    expected.sort((first, second) => first.orderId - second.orderId);

    const orders = await repository.getOrdersByStore(storeName);
    orders.sort((first, second) => first.orderId - second.orderId);

    t.deepEqual(orders, expected);

    await repository.deleteOrders(orders.map(order => order.orderId), storeName);
    await repository.deleteStore(storeName);
});

test('saveOrder insert', async t => {
    const storeName = chance.word();
    let store = utils.createStore(storeName);
    await repository.insertStore(store);

    const expected = utils.createOrders(storeName)[0];
    await repository.saveOrder(expected, storeName);
    const order = await repository.getOrder(expected.orderId, storeName);

    t.deepEqual(order, expected);

    await repository.deleteOrder(expected.orderId, storeName);
    await repository.deleteStore(storeName);
});

test('saveOrder update', async t => {
    const storeName = chance.word();
    let store = utils.createStore(storeName);
    await repository.insertStore(store);

    const order = utils.createOrders(storeName)[0];
    await repository.saveOrder(order, storeName);
    const originalOrder = await repository.getOrder(order.orderId, storeName);

    const changedOrder = {
        ...originalOrder,
        latestEvent: utils.createLatestEvent()
    }
    await repository.saveOrder(changedOrder, storeName);
    const updatedOrder = await repository.getOrder(order.orderId, storeName);
    const expected = {
        ...order,
        latestEvent: utils.createLatestEvent()
    }
    t.deepEqual(updatedOrder, expected);

    await repository.deleteOrder(order.orderId, storeName);
    await repository.deleteStore(storeName);
})
